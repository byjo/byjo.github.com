2018-12-26
algorithm

## 가장 빠른 정렬에 대해서 설명해주세요.

- 일반적으로 quick sort가 가장 빠르다 : O(nlogn)
    - divide and conquer를 이용
    - pivot(기준 원소)을 정하고 이 기준보다 작은 원소들로 이루어진 그룹과 큰 원소들로 구성된 그룹, 총 2개의 그룹으로 나눈다
    - 이 두 개의 하위 배열에 대해서 재귀적으로 퀵소트를 수행한다
    - time complexity
        - T(n) = T(0...p-1) + T(p+1...n) + a(n)
        - n개의 원소를 퀵소트하는 시간 : 하위 그룹을 정렬하는데 걸리는 시간 + a(pivot 결정 및 그룹 나누기)
        - 하위 그룹의 원소 수가 균등하게 나눠 질 경우
            - h : 퀵소트 재귀 호출의 수
            - 2^h = n
            - h = logn
            - 즉 logn번 퀵소트가 호출 되고, 퀵소트가 호출 됐을 때 분할 하는데 O(n) 소요
            - ⇒ O(nlogn)
        - 최악의 경우 (1개, 나머지의 하위 그룹으로 나뉠 경우)
            - 퀵소트 n번 호출
            - ⇒ O(n^2)
- merge sort도 동일한 시간 복잡도를 가진다. O(nlogn)
    - merge sort도 divide and conquer를 이용해 정렬을 한다
    - 하위 그룹을 균등하게 나누고, 이에 대해 재귀적으로 정렬을 수행한다
    - 정렬된 하위 그룹을 단일 그룹으로 merge 하는 과정에서 각 그룹의 원소들을 비교하여 정렬한다
    - 항상 O(nlogn)의 시간 복잡도를 갖지만, 정렬 과정에서 배열 복제등이 일어나 상수 시간에서 차이가 나서,,, 원소의 개수 n이 커질수록 느리다고 함,,, (진짜일까)
- 그러나 특수한 경우, 다른 정렬이 더 빠를수도 있다
    - 정렬할 원소들의 성격에 따라 radix sort, bucket이 더 빠를 수도 있다
    - 귀찮아서,,생략