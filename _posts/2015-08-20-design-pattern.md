---
layout: post
title: "디자인 패턴 정리"
description: ""
category: "Design Pattern" 
tags: [Java, Design Pattern]
---
## Template Method
- 슈퍼 클래스에 로직의 흐름을 만들고, 기능의 일부를 추상 메소드 혹은 protected method로 분리, 서브 클래스에서 이를 구현하여 사용하도록 함
- 기반 클래스 코드가 오버라이딩 가능한 메소드를 호출하고, 메소드의 구현은 기반클래스를 구현 상속한 클래스에서 제공
    : 부모 클래스에서 메소드만 정의(abstract*/default), 구현은 자식 클래스에서  
    :class type은 부모 인데, 생성은 자식 class인듯.  
    : 로직의 흐름은 부모 클래스에 있기 때문에 interface일 수는 없다!  
- 기능확장
- extends의 단점(높은 결합도, 원하지 않는 메소드 상속 등등:"깨지기 쉬운 기반 클래스")을 갖고 있음 

## Factory Method
- 슈퍼 클래스에서는 서브 클래스에서 구현할 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용 
- 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정 
- 객체를 생성하기 위해 인터페이스를 정의, 어떤 클래스의 객체를 생성할지는 하위 클래스에서 결정 
: 슈퍼클래스 팩토리가 있고, 이를 상속받은 서브클래스 팩토리에 따라 생성되는 오브젝트가 달라짐 

## Strategy
기능에서 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리

## 데코레이터
부가적인 기능을 런타임 시에 다이나믹하게 부여 
타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴

## 프록시 
프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다.
대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.